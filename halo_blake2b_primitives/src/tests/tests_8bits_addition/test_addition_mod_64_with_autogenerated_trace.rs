use crate::auxiliar_functions::value_for;
use crate::tests::tests_8bits_addition::addition_mod_64_circuit_8bits_autogenerated::AdditionMod64Circuit8BitsAutogenerated;
use halo2_proofs::dev::MockProver;
use halo2_proofs::halo2curves::bn256::Fr;

#[test]
fn test_positive_addition() {
    let a = 150u128;
    let b = 50u128;
    let expected_result = 200u128;
    let expected_carry = 0u128;
    _test_addition(a, b, expected_result, expected_carry);
}
#[test]
#[should_panic]
fn test_wrong_addition() {
    let a = 150u128;
    let b = 30u128;
    let expected_result = 200u128;
    let expected_carry = 0u128;
    _test_addition(a, b, expected_result, expected_carry);
}

#[test]
fn test_positive_addition_with_0() {
    let a = 150u128;
    let b = 0u128;
    _test_addition(a, b, a, 0u128);
}

#[test]
fn test_positive_addition_with_carry() {
    let a = 2593u128;
    let b = (1u128 << 64) - 1;
    _test_addition(a, b, a - 1, 1u128);
}

// aux

fn _test_addition(a: u128, b: u128, expected_result: u128, expected_carry: u128) {
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        value_for(a),
        value_for(b),
        value_for(expected_result),
        value_for(expected_carry),
    );
    let prover = MockProver::run(17, &circuit, vec![]).unwrap();
    prover.verify().unwrap();
}
