use crate::tests::tests_addition::addition_mod_64_circuit_8bits_autogenerated::AdditionMod64Circuit8BitsAutogenerated;
use midnight_proofs::dev::MockProver;
use midnight_proofs::halo2curves::bn256::Fr;
use crate::tests::blake2b_value_for;

#[test]
fn test_positive_addition() {
    let a = 150u64;
    let b = 50u64;
    let expected_result = 200u64;
    let expected_carry = 0u64;
    run_test_for_addition(a, b, expected_result, expected_carry);
}
#[test]
#[should_panic]
fn test_wrong_addition() {
    let a = 150u64;
    let b = 30u64;
    let expected_result = 200u64;
    let expected_carry = 0u64;
    run_test_for_addition(a, b, expected_result, expected_carry);
}

#[test]
fn test_positive_addition_with_0() {
    let a = 150u64;
    let b = 0u64;
    run_test_for_addition(a, b, a, 0u64);
}

#[test]
fn test_positive_addition_with_carry() {
    let a = 2593u64;
    let b = ((1u128 << 64) - 1) as u64;
    run_test_for_addition(a, b, a - 1, 1u64);
}

// aux

fn run_test_for_addition(a: u64, b: u64, expected_result: u64, expected_carry: u64) {
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        blake2b_value_for(a),
        blake2b_value_for(b),
        blake2b_value_for(expected_result),
        blake2b_value_for(expected_carry),
    );
    let prover = MockProver::run(17, &circuit, vec![]).unwrap();
    prover.verify().unwrap();
}
