use super::*;
use crate::base_operations::addition_mod_64::AdditionMod64Config;
use crate::base_operations::decompose_8::Decompose8Config;

mod test_addition_mod_64_with_autogenerated_trace;
mod test_addition_mod_64_with_processed_trace;

mod addition_mod_64_circuit_8bits;
mod addition_mod_64_circuit_8bits_autogenerated;

#[derive(Clone, Debug)]
pub struct AdditionMod64Config8Bits<F: PrimeField + Clone> {
    sum_8bits_config: AdditionMod64Config,
    decompose_8_config: Decompose8Config,
    _ph: PhantomData<F>,
}

impl AdditionMod64Config {
    /// This method is meant to receive a valid addition_trace, and populate the circuit with it
    /// The addition trace is a matrix with 3 rows and R columns. The rows represent the two
    /// parameters of the addition and its result.
    /// Each row has the following format:
    ///    [full_number, limb_0, ..., limb_R-2, carry]
    /// Note that the carry value is not used in the parameters of the addition, but it is used
    /// to calculate its result.
    fn populate_addition_rows<F: PrimeField>(
        &self,
        layouter: &mut impl Layouter<F>,
        addition_trace: [[Value<F>; 9]; 3],
        decompose_config: &impl Decomposition,
    ) -> Result<(), Error> {
        layouter.assign_region(
            || "sum",
            |mut region| {
                self.q_add.enable(&mut region, 0)?;

                let row = addition_trace[0].to_vec();
                decompose_config.populate_row_from_values(&mut region, &row, 0, false)?;

                let row = addition_trace[1].to_vec();
                decompose_config.populate_row_from_values(&mut region, &row, 1, false)?;

                let row = addition_trace[2].to_vec();
                decompose_config.populate_row_from_values(&mut region, &row, 2, true)?;
                Ok(())
            },
        )?;
        Ok(())
    }
}
