use super::*;
use crate::base_operations::addition_mod_64::{AdditionConfigWith8Limbs, AdditionMod64Config};
use crate::base_operations::decompose_8::Decompose8Config;

mod test_addition_mod_64_with_autogenerated_trace;
mod test_addition_mod_64_with_processed_trace;

mod addition_mod_64_circuit_8bits;
mod addition_mod_64_circuit_8bits_autogenerated;

mod addition_mod_64_circuit_16bits;
mod addition_mod_64_tests_16bits;

#[derive(Clone, Debug)]
pub struct AdditionMod64Config8Bits<F: PrimeField + Clone> {
    sum_8bits_config: AdditionConfigWith8Limbs,
    decompose_8_config: Decompose8Config,
    _ph: PhantomData<F>,
}

impl<const T: usize, const R: usize> AdditionMod64Config<T, R> {
    /// This method is meant to receive a valid addition_trace, and populate the circuit with it
    /// The addition trace is a matrix with 3 rows and R columns. The rows represent the two
    /// parameters of the addition and its result.
    /// Each row has the following format:
    ///    [full_number, limb_0, ..., limb_R-2, carry]
    /// Note that the carry value is not used in the parameters of the addition, but it is used
    /// to calculate its result.
    fn populate_addition_rows<F: PrimeField>(
        &self,
        layouter: &mut impl Layouter<F>,
        addition_trace: [[Value<F>; R]; 3],
        decompose_config: &impl Decomposition<T>,
    ) -> Result<(), Error> {
        layouter.assign_region(
            || "decompose",
            |mut region| {
                self.q_add.enable(&mut region, 0)?;

                self.populate_row_from_values(
                    &mut region,
                    addition_trace[0].to_vec(),
                    0,
                    decompose_config,
                )?;
                self.populate_row_from_values(
                    &mut region,
                    addition_trace[1].to_vec(),
                    1,
                    decompose_config,
                )?;
                self.populate_row_from_values(
                    &mut region,
                    addition_trace[2].to_vec(),
                    2,
                    decompose_config,
                )
            },
        )?;
        Ok(())
    }

    fn populate_row_from_values<F: PrimeField>(
        &self,
        region: &mut Region<F>,
        row: Vec<Value<F>>,
        offset: usize,
        decompose_config: &impl Decomposition<T>,
    ) -> Result<(), Error> {
        decompose_config.populate_row_from_values(region, &row, offset)?;
        region.assign_advice(|| "carry", self.carry, offset, || row[R - 1])?;
        Ok(())
    }
}
