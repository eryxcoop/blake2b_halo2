use crate::auxiliar_functions::value_for;
use crate::tests::tests_8bits_addition::addition_mod_64_circuit_8bits_autogenerated::AdditionMod64Circuit8BitsAutogenerated;
use halo2_proofs::dev::MockProver;
use halo2_proofs::halo2curves::bn256::Fr;

#[test]
fn test_positive_addition() {
    let a = 150u128;
    let b = 50u128;
    let expected_result = 200u128;
    let expected_carry = 0u128;
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        value_for(a),
        value_for(b),
        value_for(expected_result),
        value_for(expected_carry),
    );
    let prover = MockProver::run(17, &circuit, vec![]).unwrap();
    prover.verify().unwrap();
}
#[test]
#[should_panic]
fn test_wrong_addition() {
    let a = 150u128;
    let b = 30u128;
    let expected_result = 200u128;
    let expected_carry = 0u128;
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        value_for(a),
        value_for(b),
        value_for(expected_result),
        value_for(expected_carry),
    );
    let prover = MockProver::run(17, &circuit, vec![]).unwrap();
    prover.verify().unwrap();
}

#[test]
fn test_positive_addition_with_0() {
    let a = 150u128;
    let b = 0u128;
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        value_for(a),
        value_for(b),
        value_for(a),
        value_for(0u128),
    );
    let prover = MockProver::run(17, &circuit, vec![]).unwrap();
    prover.verify().unwrap();
}

#[test]
fn test_positive_addition_with_carry() {
    let a = 2593u128;
    let b = (1u128 << 64) - 1;
    let expected_result = a - 1;
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        value_for(a),
        value_for(b),
        value_for(expected_result),
        value_for(1u128),
    );
    let prover = MockProver::run(17, &circuit, vec![]).unwrap();
    prover.verify().unwrap();
}

#[test]
fn test_negative_addition() {
    let a = 2593u128;
    let b = (1u128 << 64) - 1;
    let expected_result = a - 1;
    let circuit = AdditionMod64Circuit8BitsAutogenerated::<Fr>::new_for(
        value_for(a),
        value_for(b),
        value_for(expected_result),
        value_for(1u128),
    );
    let instance = vec![];
    let (n, mut prover) = MockProver::<Fr>::synthesize_circuit(17, &circuit, instance).unwrap();

    let sum_region = &prover.regions[1];
    let prover = MockProver::<Fr>::generate_proof(n, prover);
    prover.verify().unwrap();
}

// aux
